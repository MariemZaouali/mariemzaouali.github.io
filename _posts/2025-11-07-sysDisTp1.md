---
layout: post
title: TP1 du client-serveur à l'invocation des méthodes
subtitle: Troisième TP
tags: [Système Distribué,Java]
author: Mariem ZAOUALI
---

# TP1 du client-serveur à l'invocation des méthodes
Objectifs du TP :
>
> Au terme de ce TP, vous serez capable de :
>•	Créer des applications client/serveur utilisant les sockets avec TCP et UDP
>•	Gérer le problème de concurrence de plusieurs clients se connectant à un seul serveur (le multi-threading)
>•	Répartir l’application et appeler un objet distant
>

## Manipulation 1
### Première partie : Le but de cette manipulation de démo de créer :
-  Une application client/serveur utilisant les sockets en mode connecté (protocole de transport utilisé TCP)
-  Une application client/serveur utilisant les sockets en mode non connecté (protocole de transport utilisé UDP)

Client_TCP
```java
import java.io.*;
import java.net.Socket;
import java.util.Scanner;

/**
 * Client TCP générique pouvant se connecter à un serveur donné.
 * Compatible avec plusieurs serveurs (Server1, Server2, Server3...).
 */
public class Client {

    private final String serverName = "localhost"; // Adresse du serveur
    private final int serverPort = 8081;           // Port du serveur

    public Client() {
        System.out.println("=== Client TCP ===");

        try (
            // Création automatique de la socket et des flux
            Socket socket = new Socket(serverName, serverPort);
            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
            DataInputStream dis = new DataInputStream(socket.getInputStream());
            Scanner scanner = new Scanner(System.in)
        ) {
            System.out.println("Client démarré sur le port " + socket.getLocalPort());
            System.out.println("Connecté à " + socket.getRemoteSocketAddress());
            System.out.println("Tapez 'exit' pour quitter.\n");

            while (true) {
                System.out.print("Message à envoyer : ");
                String messageToServer = scanner.nextLine().trim();

                // Quitter proprement
                if (messageToServer.equalsIgnoreCase("exit")) {
                    dos.writeUTF("exit");
                    break;
                }

                // Envoi du message
                dos.writeUTF(messageToServer);
                dos.flush();

                // Lecture de la réponse du serveur
                String messageFromServer = dis.readUTF();
                if (messageFromServer.equalsIgnoreCase("exit")) {
                    System.out.println("Serveur a fermé la connexion.");
                    break;
                }

                System.out.println("[" + socket.getRemoteSocketAddress() + "] → " + messageFromServer);
            }

            System.out.println("Déconnexion du client...");

        } catch (IOException e) {
            System.err.println("Erreur de communication : " + e.getMessage());
        }

        System.out.println("Client arrêté.");
    }

    public static void main(String[] args) {
        new Client();
    }
}
```` 
Serveur_TCP
```java
import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

/**
 * Serveur TCP simple — dialogue avec un client unique.
 * Compatible avec le client TCP utilisant DataInputStream/DataOutputStream.
 */
public class Server {

    private final int port = 8081;  // Port d’écoute

    public Server() {
        System.out.println("=== Serveur TCP ===");

        try (ServerSocket serverSocket = new ServerSocket(port)) {

            System.out.println("Serveur démarré sur le port " + serverSocket.getLocalPort());
            System.out.println("En attente d’un client...\n");

            // Attente d'une connexion
            try (
                Socket socket = serverSocket.accept();
                DataInputStream dis = new DataInputStream(
                        new BufferedInputStream(socket.getInputStream()));
                DataOutputStream dos = new DataOutputStream(
                        new BufferedOutputStream(socket.getOutputStream()));
                Scanner scanner = new Scanner(System.in)
            ) {
                System.out.println("Client " + socket.getRemoteSocketAddress() + " connecté.");

                while (true) {
                    // Lecture du message du client
                    String messageFromClient = dis.readUTF().trim();
                    if (messageFromClient.equalsIgnoreCase("exit")) {
                        System.out.println("Client a demandé la fermeture.");
                        break;
                    }

                    System.out.println("[Client " + socket.getRemoteSocketAddress() + "] → " + messageFromClient);

                    // Préparer la réponse
                    System.out.print("Message à envoyer : ");
                    String messageToClient = scanner.nextLine().trim();

                    // Si le serveur tape 'exit', il ferme la session
                    if (messageToClient.equalsIgnoreCase("exit")) {
                        dos.writeUTF("exit");
                        dos.flush();
                        break;
                    }

                    // Envoi de la réponse
                    dos.writeUTF(messageToClient);
                    dos.flush();
                }

                System.out.println("Client " + socket.getRemoteSocketAddress() + " déconnecté.");
            }

        } catch (IOException e) {
            System.err.println("Erreur du serveur : " + e.getMessage());
        }

        System.out.println("Serveur arrêté.");
    }

    public static void main(String[] args) {
        new Server();
    }
}

```

ClientUDP
```java
import java.io.*;
import java.net.*;

/**
 * Client UDP qui envoie un message sérialisé à un serveur donné.
 */
public class UDPClient {

    public static void main(String[] args) {
        final int SERVER_PORT = 8081;
        final String SERVER_HOST = "localhost";
        final String MESSAGE = "Bonjour du cours de UDP envoyé du client !";

        System.out.println("=== UDP Client ===");

        // try-with-resources : fermeture automatique du socket
        try (DatagramSocket socket = new DatagramSocket()) {

            InetAddress serverAddress = InetAddress.getByName(SERVER_HOST);
            System.out.println("Serveur ciblé : " + serverAddress.getHostAddress() + ":" + SERVER_PORT);

            // Sérialisation du message dans un flux de bytes
            byte[] sendBuffer = serializeObject(MESSAGE);

            // Création du datagramme à envoyer
            DatagramPacket packet = new DatagramPacket(sendBuffer, sendBuffer.length, serverAddress, SERVER_PORT);

            // Envoi du datagramme
            socket.send(packet);
            System.out.println("Message envoyé au serveur : \"" + MESSAGE + "\"");

        } catch (UnknownHostException e) {
            System.err.println("Adresse du serveur inconnue : " + SERVER_HOST);
        } catch (IOException e) {
            System.err.println("Erreur d’E/S : " + e.getMessage());
        }

        System.out.println("Client UDP terminé.");
    }

    /**
     * Sérialise un objet Java en tableau d’octets.
     */
    private static byte[] serializeObject(Object obj) {
        try (
            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(byteStream))
        ) {
            oos.writeObject(obj);
            oos.flush();
            return byteStream.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException("Erreur de sérialisation de l’objet : " + e.getMessage(), e);
        }
    }
}
```
Serveur UDP
```java
import java.io.*;
import java.net.*;

/**
 * Serveur UDP qui reçoit un message sérialisé depuis un client.
 */
public class UDPServer {

    private static final int SERVER_PORT = 8081;
    private static final int BUFFER_SIZE = 5000;
    private static final int TIMEOUT_MS = 30000; // 30 secondes

    public static void main(String[] args) {
        System.out.println("=== UDP Server ===");
        new UDPServer().runServer();
    }

    public void runServer() {
        try (DatagramSocket socket = new DatagramSocket(SERVER_PORT)) {
            System.out.println("Serveur en écoute sur le port " + SERVER_PORT + "...");
            socket.setSoTimeout(TIMEOUT_MS);

            byte[] buffer = new byte[BUFFER_SIZE];
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

            // Attente de la réception
            try {
                socket.receive(packet);
                System.out.println("Paquet reçu depuis : " +
                        packet.getAddress().getHostAddress() + ":" + packet.getPort());

                // Traitement du message
                String message = deserializeObject(packet.getData());
                System.out.println("Message reçu du client : " + message);

            } catch (SocketTimeoutException e) {
                System.err.println(" Timeout : aucun paquet reçu dans le délai imparti (" + TIMEOUT_MS + " ms).");
            }

        } catch (SocketException e) {
            System.err.println("Erreur lors de la création du socket : " + e.getMessage());
        } catch (IOException e) {
            System.err.println("Erreur d’E/S lors de la réception : " + e.getMessage());
        }

        System.out.println("Serveur arrêté.");
    }

    /**
     * Désérialise un objet à partir d’un tableau d’octets.
     */
    private String deserializeObject(byte[] data) {
        try (
            ByteArrayInputStream byteStream = new ByteArrayInputStream(data);
            ObjectInputStream ois = new ObjectInputStream(new BufferedInputStream(byteStream))
        ) {
            return (String) ois.readObject();
        } catch (IOException e) {
            throw new RuntimeException("Erreur de désérialisation : " + e.getMessage(), e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Classe non trouvée pour l’objet reçu.", e);
        }
    }
}
```
### Deuxième partie : 
On veut développer une application client/serveur permettant d’afficher le nombre de places disponibles pour chaque spectacle. Le serveur détient la liste des spectacles avec les places respectives disponibles. Par exemple, le spectacle de « spectacle A» a 10 places disponibles, le spectacle « spectacle B» a 11 places disponibles.
Créer une application client/serveur qui permet à un client de se connecter au serveur et de demander la liste des spectacles disponibles. 
Quel protocole de transport avez-vous choisi ?

## Manipulation 2
### Première partie : 

Le but de cette manipulation démo est de créer :
•	Une application client/serveur multi-threadée utilisant les sockets en mode connecté (protocole de transport utilisé TCP)

Client
```java
import java.io.*;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.Date;

public class ClientDemo1 {

    private static final String SERVER_HOST = "localhost";
    private static final int SERVER_PORT = 7771;

    public static void main(String[] args) {

        try (
            Socket socket = new Socket(SERVER_HOST, SERVER_PORT);
            DataOutputStream dos = new DataOutputStream(
                    new BufferedOutputStream(socket.getOutputStream()));
            DataInputStream dis = new DataInputStream(
                    new BufferedInputStream(socket.getInputStream()))
        ) {
            // Messages à envoyer
            sendMessage(dos, "HELLO! now is " + new Date());
            sendMessage(dos, "Trial");
            sendMessage(dos, "QUIT");

            // Lecture de la réponse du serveur
            readServerResponses(dis);

        } catch (UnknownHostException e) {
            System.err.println("Unknown host: " + SERVER_HOST);
        } catch (IOException e) {
            System.err.println("I/O error while connecting to " + SERVER_HOST + ":" + SERVER_PORT);
            e.printStackTrace();
        }
    }

    /** Envoie un message au serveur et flush le flux. */
    private static void sendMessage(DataOutputStream dos, String message) throws IOException {
        dos.writeUTF(message);
        dos.flush();
    }

    /** Lit les réponses du serveur jusqu’à un message contenant "OK". */
    private static void readServerResponses(DataInputStream dis) throws IOException {
        String response;
        while ((response = dis.readUTF()) != null) {
            System.out.println("Server: " + response);
            if (response.contains("OK")) {
                break;
            }
        }
    }
}
````

Serveur - Thread
```java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.Socket;

public class ServiceThread1 extends Thread {

    private final int clientNumber;
    private final Socket socketOfServer;

    public ServiceThread1(Socket socketOfServer, int clientNumber) {
        this.clientNumber = clientNumber;
        this.socketOfServer = socketOfServer;

        // Log propre
        ServerProgram1.log("Nouvelle connexion avec le client #" + clientNumber +
                           " depuis " + socketOfServer.getInetAddress() + ":" + socketOfServer.getPort());
    }

    @Override
    public void run() {
        try (
            DataInputStream dis = new DataInputStream(new BufferedInputStream(socketOfServer.getInputStream()));
            DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(socketOfServer.getOutputStream()))
        ) {
            // Exemple : on envoie un message de bienvenue
            String message = "Bonjour client #" + clientNumber + " ! Bienvenue sur le serveur.\n";
            dos.writeUTF(message);
            dos.flush();

            // Lecture éventuelle depuis le client (facultatif)
            // String clientMessage = dis.readUTF();
            // ServerProgram1.log("Message reçu du client #" + clientNumber + ": " + clientMessage);

        } catch (IOException e) {
            ServerProgram1.log("Erreur avec le client #" + clientNumber + " : " + e.getMessage());
            e.printStackTrace();
        } finally {
            try {
                socketOfServer.close();
                ServerProgram1.log("Connexion fermée avec le client #" + clientNumber);
            } catch (IOException e) {
                ServerProgram1.log("Erreur lors de la fermeture de la connexion du client #" + clientNumber);
            }
        }
    }
}
```
Serveur 
```java
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class ServerProgram1 {

    private static final int PORT = 7771;

    public static void main(String[] args) {
        System.out.println("Serveur en attente de connexions sur le port " + PORT + "...");
        int clientNumber = 1;

        // Utilisation du try-with-resources pour garantir la fermeture du ServerSocket
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            while (true) {
                // Attente d'une connexion client
                Socket clientSocket = serverSocket.accept();

                // Log clair
                log("Connexion acceptée depuis " + clientSocket.getInetAddress() + ":" + clientSocket.getPort());

                // Lancement du thread client
                new ServiceThread1(clientSocket, clientNumber++).start();
            }

        } catch (IOException e) {
            log("Erreur lors de la création ou de l'écoute du serveur : " + e.getMessage());
            e.printStackTrace();
        }

        // Ce message n’est jamais atteint en mode serveur continu,
        // mais utile si la boucle est interrompue.
        log("Serveur arrêté.");
    }

    /** Méthode centralisée de log pour uniformiser les sorties. */
    public static void log(String message) {
        System.out.println("[Server] " + message);
    }
}
```
### Deuxième partie : 

L’application développée dans la manipulation 1 de la consultation des spectacles, sera étendue dans cette manipulation, pour simuler la connexion de plusieurs clients qui se connectent sur un seul serveur pour obtenir la liste des spectacles avec leurs places disponibles respectives.
	Défis à relever dans ce cas et solutions ?
